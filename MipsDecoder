# Authors Aster Bodden and Stephen Yee 
.data
# Area for global values , constants strings 

.text 
# Area for the code 

#Main program should: 
# Accept a machineinstruction word and its address as two stringsfrom the user
# Extract the numeric value from the input strings
# Call subroutine get_type print the format type (I/J/R) "invalid" if not supported
# Call subroutine get_dest_reg print the destination register number of the instruction (decimal value), "none" for no destination or invalid if not supported
# Call subroutine get_next_pc print(HEX) the address(es)of the next instruction, if not supported print invalid
# Operations supported  add, addi, sub, slt, lw, sw, beq, j. 
main: 
	addi $a0, $zero, 0x08124553
	jal get_dest_reg
	j ex1 # finish program 



# required subroutines 
#Parameter:instruction is a 32-bit unsigned number representing a machine instruction word.
# Return: an integer with the following possible values of 1-R type, 2-I type, 3-J type, 0-not supported
.globl get_type
get_type:
	
	# push stacks values to restore  before the call ends
	addi $sp, $sp, -16
	sw $s0, 4($sp) 
	sw $s1, 8($sp) 
	sw $ra, 12($sp)

	# R types will have the opcode set to 0 and func can be 32 34 42 
	# I type ocodes are 8 35 and 43 
	# J type will have opcode 2
	
	#obtain Op code and function code 
	sw $a0, 0($sp) #save instruction parameter 
	jal getOpcode
	add $s0, $v0, $zero # save returned OP code 
	lw $a0, 0($sp) #restore instruction 
	jal getFunc 
	add $s1, $v0, $zero # save returned Function code 
	
	add $v0, $zero, $zero # return register if invalid set to 0
	
	#check the OP code
	addi $t0, $zero, 2 
	beq $s0, $zero, R
	beq $s0, $t0, J
	I:
 		addi $t0, $zero, 4  #beq
 		addi $t1, $zero, 35 #lw
 		addi $t2, $zero, 43 #sw
 		# check that Opcode is valid 
 		beq $s0,$t0, goodI  
 		beq $s0,$t1, goodI 
 		beq $s0,$t2, goodI
 		j exit #not a supported type
 		goodI: 
 			addi $v0, $zero, 1
 			j exit
 	R:  
 		addi $t0, $zero, 32 # add
 		addi $t1, $zero, 34 # sub
 		addi $t2, $zero, 42 # slt 
 		# check that Func is valid 
 		beq $s1,$t0, goodR  
 		beq $s1,$t1, goodR 
 		beq $s1,$t2, goodR
 		j exit #not a supported type
 		goodR: 
 			addi $v0, $zero, 2
 			j exit
	J: 	# set return value to 3
		addi $v0, $zero, 3
	
	exit: 
		# restore Saved registers and retrun address to original value 
		lw $s0 , 4($sp) 
		lw $s1, 8($sp) 
		lw $ra, 12($sp)
		#restore stack to original value 
		addi $sp, $sp, 16
		jr $ra 
	
#Parameter: instruction is a 32-bit unsigned number representing a machine instruction word.
# return: 
	#an integer representing the register number which will be updated by executing of this instruction.
	# A valid return should be within the range of [0,31]'
	# Return 32 if no register gets updated by the instruction
	# Retrun 0 for invalid instruction or invalid destination register
	#Note: some instruction might update $rt instead of $rd
.globl get_dest_reg
get_dest_reg: 
	#make room in stack for ra and other saved variables
	addi $sp, $sp, -8
	sw $ra, 4($sp) # store return address 
	sw $a0, 0($sp) # store paramter 
	# get instruction type 
	jal get_type 
	add $t0, $v0, $zero #save return type 
	beq $t0, $zero, end #if it is an invalid instruction return 0
	
	addi $t1, $zero , 1 
	addi $t3, $zero , 3
	
	beq $t1, $t0, It
	beq $t3, $t0, noUpdate
	# R type 
	Rt:
		lw $a0, 0($sp) # restore instruction
		addi $a1, $zero, 2 # 2ndparam is what register to get (2 = rd)
		jal getRreg # get rd 
		j end 
	
	# I type 
	It:
		lw $a0, 0($sp) #restore instruction before call 
		jal getOpcode #get opcode 
		addi $t0 , $zero, 35
		bne $v0, $t0, noUpdate # this instruction does not update any registers 
		
		lw $a0, 0($sp) #restore instruction before call 
		addi $a1, $zero, 1 # 2ndparam is what register to get (1 = rt)
		jal getRreg #get rt
		j end 
	
	# J type or any instruction that does not modify a register  
	noUpdate: 
		addi $v0 , $zero, 32
	
	end: 
		#restore return address 
		lw $ra, 4($sp) 
		addi $sp , $sp, 8 # restore stack to original size 
		jr $ra
		
#Parameter: instruction is a 32-bit unsigned number representing a machine instruction word.
#	    addr is a 32-bit unsigned number representing the address (PC) of instruction.
# return: 
# For sequential and jump instructions, return an integer representing the address of the next instruction we will fetch and execute in $v0
# For branch return two integers if taken return address in v1, if not taken return address in v0 
#  next pc is never going to be zero and return 0 in $v0 for invalid instructions
.globl get_next_pc
get_next_pc:

	addi $sp, $sp, -12
	sw $ra, 8($sp) 
	sw $a0, 4($sp) 
	sw $a1, 0($sp) 
	
	#check if the instruction is a valid instruction 
	jal get_type #return type in $v0 
	
	#restore parameter values 
	lw $a0, 4($sp) 
	lw $a1, 0($sp) 
	
	beq $zero, $v0, finish # retrun if the instruction is invalid 
	addi $t0, $zero, 3 # 3 = jump instruction 
	beq $t0, $v0, ujump # if type is 3 find jump target 
	
	jal getOpcode # get the instruction opcode 
	
	#restore parameter values 
	lw $a0, 4($sp) 
	lw $a1, 0($sp)
	
	add $t1, $v0, $zero #save instruction opcode in t1 
	addi $v0, $a1, 4 # PC + 4 in return register 
	addi $t0, $zero, 0x4 # beq opcode = 4
	bne $t1, $t0, finish #  if it is not a beq instruction target address is already calculated  
	
	# branch is taken : 
	# for the branch instruction we have to do an extra step by getting the imidiate value mult by 4 
	# and this result add it to PC + 4 
	andi $t0, $a0 , 0xFFFF # save the lower  16 bits that have the Imidiate value
	sll $v1 , $t0, 2 # multiply the immidiate by 4 
	# add the IMM * 4 to (PC + 4) 
	# PC + 4 was already calculated and stored in $v0 
	add $v1, $v1, $v0 # IMM*4 + PC + 4 
	
	j finish 
	# Jump instruction we have to mult immidiate  by 4 and mask the last 4 bits of the current PC to new PC
	ujump: 
		andi $t0, $a0 , 0x3FFFFFF # save the lower  26 bits that have the Imidiate value
		andi $t1, $a1, 0xF0000000 # save the last 4 bits from current PC
		sll $v0 , $t0, 2 # multiply the immidiate by 4 
		#merge Immidiate * 4 and the last four bits of current address 
		or $v0, $v0, $t1 # jump stored in $v0  
			
	finish: 
		lw $ra, 8($sp) #restore return address
		addi $sp, $sp, 12 

# Helper subroutines 
getOpcode: 
	srl $v0, $a0, 26
	jr $ra
getFunc: 
	andi $v0, $a0, 0x3F
	jr $ra
# gets the register in instruction $a0 at position $a1
# 0 = rs 
# 1 = rt
# 2 = rd 
getRreg: 
	addi $t0, $zero, 1
	beq $a1, $zero, rs 
	beq $a1, $t0, rt 
	rd: 
		srl $v0, $a0, 11 #shift to rd position 
		j return 		
	rs:
		srl $v0, $a0, 21 #shift to rs position
		j return 
	rt: 
		srl $v0, $a0, 16 #shift to rt position
	
	return: 
		#save only the six bits needed for registers
		andi $v0, $v0, 0x1F
		jr $ra 

# program finished 
ex1:
